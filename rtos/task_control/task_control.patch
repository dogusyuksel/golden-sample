diff --git a/rtos/base_example/src/main.c b/rtos/base_example/src/main.c
index 09b0f6c..5a65221 100644
--- a/rtos/base_example/src/main.c
+++ b/rtos/base_example/src/main.c
@@ -1,14 +1,90 @@
 #include "main.h"
+#include "FreeRTOS.h"
+#include "task.h"
+#include <stdio.h>
+#include <string.h>
 
 UART_HandleTypeDef hlpuart1;
-
 PCD_HandleTypeDef hpcd_USB_OTG_FS;
 
+TaskHandle_t xHandle = NULL;
+
 void SystemClock_Config(void);
 static void MX_GPIO_Init(void);
 static void MX_LPUART1_UART_Init(void);
 static void MX_USB_OTG_FS_PCD_Init(void);
 
+void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {
+    if (GPIO_Pin == B1_Pin) {
+        HAL_GPIO_TogglePin(GPIOB, LD2_Pin);
+
+        char buffer[256] = {0};
+        static uint8_t counter = 0;
+
+        snprintf(buffer, sizeof(buffer), "counter: %d\n", counter++);
+
+        HAL_UART_Transmit(&hlpuart1, (uint8_t *)buffer, strlen(buffer), 100);
+
+        if (counter == 10) {
+            HAL_UART_Transmit(&hlpuart1, (uint8_t *)"task deleted\n\0", 14, 100);
+            if( xHandle != NULL ) {
+                vTaskDelete(xHandle);
+            }
+        }
+
+        TaskHandle_t xHandle_by_name;
+        TaskStatus_t xTaskDetails;
+
+        /* Obtain the handle of a task from its name. */
+        xHandle_by_name = xTaskGetHandle( "mytask" );
+
+        /* Check the handle is not NULL. */
+        configASSERT( xHandle_by_name );
+
+        /* Use the handle to obtain further information about the task. */
+        vTaskGetInfo( /* The handle of the task being queried. */
+                    xHandle_by_name,
+                    /* The TaskStatus_t structure to complete with information
+                    on xTask. */
+                    &xTaskDetails,
+                    /* Include the stack high water mark value in the
+                    TaskStatus_t structure. */
+                    pdTRUE,
+                    /* Include the task state in the TaskStatus_t structure. */
+                    eInvalid );
+
+        snprintf(buffer, sizeof(buffer), "eCurrentState: %ld\n", (int32_t)xTaskDetails.eCurrentState);
+
+        HAL_UART_Transmit(&hlpuart1, (uint8_t *)buffer, strlen(buffer), 100);
+    }
+}
+
+void dummy_function(void) { HAL_GPIO_TogglePin(GPIOB, LD3_Pin); }
+
+void mytask(void *data) {
+    (void)data;
+
+    TickType_t xLastWakeTime;
+    const TickType_t xFrequency_ms = 1000;
+    BaseType_t xWasDelayed;
+
+    // Initialise the xLastWakeTime variable with the current time.
+    xLastWakeTime = xTaskGetTickCount ();
+    for( ;; )
+    {
+        // Wait for the next cycle.
+        xWasDelayed = xTaskDelayUntil( &xLastWakeTime, pdMS_TO_TICKS(xFrequency_ms));
+
+        // Perform action here. xWasDelayed value can be used to determine
+        dummy_function();
+        // whether a deadline was missed if the code here took too long.
+        char buffer[256] = {0};
+
+        snprintf(buffer, sizeof(buffer), "xWasDelayed in ms: %ld\n", pdTICKS_TO_MS(xWasDelayed));
+        HAL_UART_Transmit(&hlpuart1, (uint8_t *)buffer, strlen(buffer), 100);
+    }
+}
+
 int main(void) {
 
     HAL_Init();
@@ -19,6 +95,10 @@ int main(void) {
     MX_LPUART1_UART_Init();
     MX_USB_OTG_FS_PCD_Init();
 
+    xTaskCreate(mytask, "mytask", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle);
+
+    vTaskStartScheduler();
+
     while (1) {
     }
 }
